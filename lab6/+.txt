# подход 1 против остальных - подход, кот.позвол.распр.алг.бин.классиф на случ.мультикласс.классиф
# для к.класса строится бин.модель, кот пыт.отделить класс от оттальных, в рез-те => кол-во моделей=кол-во классов
# для получения прогнза: т.тест.набора подается на все бин.классиф., тот кто выдает своему классу наиб.знач.побежд
#   его метка присваивается в кач-ве прогноза
import mglearn
import matplotlib.pyplot as plt
import numpy as np

# набор д-х с 3класс.класиф (наш метод)
from sklearn.datasets import make_blobs
X, y = make_blobs(random_state=42)
mglearn.discrete_scatter(X[:, 0], X[:, 1], y)
plt.xlabel("Признак 0")
plt.ylabel("Признак 1")
plt.legend(["Класс 0", "Класс 1", "Класс 2"])
plt.show()

# обучаем классификатор LinearSVC на этом наборе данных
from sklearn.svm import LinearSVC
linear_svm = LinearSVC().fit(X, y)
# атрибут coef_ имеет форму (3,2)
# к.стока сод.вектор коэф.для к.из 3 классов, а каждый столбец - знач.коэф для конкр.признака (в этом наборе д-х из 2)
print("Форма коэффициента: ", linear_svm.coef_.shape)
# intercept_ - одномерный массив, в котором записаны константы классов
print("Форма константы: ", linear_svm.intercept_.shape) 

# визуализируем границы принятия решений, полученные с помошью трех бинарных классификторов
mglearn.discrete_scatter(X[:, 0], X[:, 1], y)
line = np.linspace(-15, 15)
for coef, intercept, color in zip(linear_svm.coef_, linear_svm.intercept_, ['b', 'r', 'g']):
    plt.plot(line, -(line * coef[0] + intercept) / coef[1], c=color)
plt.ylim(-10, 15)
plt.xlim(-10, 8)
plt.xlabel("Признак 0")
plt.ylabel("Признак 1")
plt.legend(['Класс 0', 'Класс 1', 'Класс 2', 'Линия класса 0', 'Линия класса 1', 'Линия класса 2'], loc=(1.01, 0.3))
# все т., кот принадл.классу 0 в обуч.д-х, нах выше линии, соответствующей классу 0
#   это значит, что они отнесены к классу 0 бинарного классификатора
# точки класса 0 находятся выше линии, соответствующей классу 2
#   это значит, что они классифицируются бинарным классификатором для класса 2, как остальные
# точки класса 0, нах.слева от линии, соответтвующей клаасу 1
#   это значит, что бинарный классификатор для класса 1 также классиф.их как остальные
# Т.о.любая точка в этой области будет отнесена к классу 0
# треугольник - т.будет присвоен класс, кот получил наиб.знач.по формуле классификации,
#   т.е.класс ближайшей линии
plt.show()

# прогнозы для всех областей двумерного пространства
mglearn.plots.plot_2d_classification(linear_svm, X, fill=True, alpha=.7)
mglearn.discrete_scatter(X[:, 0], X[:, 1], y)
line = np.linspace(-15, 15)
for coef, intercept, color in zip(linear_svm.coef_, linear_svm.intercept_,
                                  ['b', 'r', 'g']):
    plt.plot(line, -(line * coef[0] + intercept) / coef[1], c=color)
plt.legend(['Класс 0', 'Класс 1', 'Класс 2', 'Линия класса 0', 'Линия класса 1',
            'Линия класса 2'], loc=(1.01, 0.3))
plt.xlabel("Признак 0")
plt.ylabel("Признак 1")
plt.show()
